#!/usr/bin/env python3
from typing import Union, Tuple,List
import numpy as np
from std_msgs.msg import Float64MultiArray
from sensor_msgs.msg import PointCloud2, LaserScan
import rospkg
import sys
import rospy
import tf
import tf2_ros
import math
import sensor_msgs.point_cloud2 as pc2
from geometry_msgs.msg import Pose, Twist, PoseStamped
from tf.transformations import euler_from_quaternion
from nav_msgs.msg import Odometry
import tf2_sensor_msgs
from ros_bridge.src.robotmpcs_ros.utils.ros_visuals import ROSMarkerPublisher
from ros_bridge.src.robotmpcs_ros.utils.transformations import quaternion_to_rotation_matrix
from robotmpcs.planner.mpcPlanner import MPCPlanner
from mpscenes.goals.goal_composition import GoalComposition
from mpscenes.obstacles.sphere_obstacle import SphereObstacle
from robotmpcs.utils.free_space_decomposition import FreeSpaceDecomposition

def get_rotation(pose: Pose) -> float:
    orientation_q = pose.orientation
    orientation_list = [orientation_q.x, orientation_q.y, orientation_q.z, orientation_q.w]
    (roll, pitch, yaw) = euler_from_quaternion(orientation_list)
    return yaw

class MPCNode():
    _action: np.ndarray
    _cmd_pub: rospy.Publisher
    _rate: rospy.Rate
    _q: np.ndarray
    _qdot: np.ndarray
    _qudot: np.ndarray
    _dt: float
    _r_body: float
    _goal: Union[GoalComposition, None]

    def __init__(self):
        rospy.init_node("mpc_node")
        self._transform = None
        self.establish_ros_connections()
        self._dt = rospy.get_param('/mpc/time_step')
        self._rate = rospy.Rate(1/self._dt)
        self.init_scenario()
        self.init_planner()
        self.set_mpc_parameter()
        self.init_arrays()
        self.init_visuals()
        self.tf_buffer = tf2_ros.Buffer()
        self.listener = tf.TransformListener()





    def init_scenario(self):
        self._goal = None
        self._lidar_pointcloud = None
        obst1Dict = {
            "type": "sphere",
            "geometry": {"position": [400.0, -1.5, 0.0], "radius": 1.0},
        }
        sphereObst1 = SphereObstacle(name="simpleSphere", content_dict=obst1Dict)
        self._obstacles = [sphereObst1]
        self._r_body = 0.6
        self._limits = np.array([
                [-10, 10],
                [-10, 10],
                [-10, 10],
        ])
        self._limits_u = np.array([
                [-10, 10],
                [-10, 10],
        ])
    def init_visuals(self):
        self.constr_color = 0

        self.visuals = ROSMarkerPublisher('/mpc_planner_node/visuals', 100)

        self.visual_constraints = self.visuals.get_line('odom')
        self.visual_constraints.set_scale(0.05)
        self.visual_constraints.set_color(self.constr_color)

        self.visual_goal = self.visuals.get_circle('odom')
        self.visual_goal.set_scale(0.4,0.4,0.01)
        self.visual_goal.set_color(1)

        self.visual_robot = self.visuals.get_circle('odom')
        self.visual_robot.set_scale(0.7,0.7,0.01)
        self.visual_robot.set_color(5)

        self.visual_plan_circle = self.visuals.get_circle('odom')
        self.visual_plan_circle.set_scale(0.4,0.4,0.1)
        self.visual_plan_circle.set_color(10,alpha=0.3)

    def init_arrays(self):
        self._action = np.zeros(2)
        self._q = np.zeros(3)
        self._qudot = np.zeros(2)
        self._qdot = np.zeros(3)

    def init_planner(self):
        self._robot_type = rospy.get_param('/mpc/model_name')
        rospack = rospkg.RosPack()
        self._solver_directory = rospack.get_path("robotmpcs_ros") + "/solvers/"
        self._config = rospy.get_param('/mpc')
        self._N = self._config['time_horizon']
        self._n_obstacles = self._config['number_obstacles']
        self._fsd = FreeSpaceDecomposition(number_constraints=self._n_obstacles, max_radius=5)
        self._planner = MPCPlanner(
            self._robot_type,
            self._solver_directory,
            **self._config)
        self._planner.concretize()
        self._planner.reset()

    def set_mpc_parameter(self):
        constraints = self._config['constraints']
        objectives = self._config['objectives']

        for objective in objectives:
            if objective == 'GoalReaching':
                try:
                    self._planner.setGoalReaching(self._goal)
                except AttributeError:
                    print('The required attributes for setting ' + objective + ' are not defined')
            elif objective == 'ConstraintAvoidance':
                try:
                    self._planner.setConstraintAvoidance()
                except KeyError:
                    print('The required attributes for setting ' + objective + ' are not defined in the config file')
            else:
                print('No function to set the parameters for this objective is defined')


        for constraint in constraints:
            if constraint == 'JointLimitConstraints':
                try:
                    self._planner.setJointLimits(np.transpose(self._limits))
                except AttributeError:
                    print('The required attributes for setting ' + constraint + ' are not defined')
            elif constraint == 'VelLimitConstraints':
                try:
                    self._planner.setVelLimits(np.transpose(self._limits_vel))
                except AttributeError:
                    print('The required attributes for setting ' + constraint + ' are not defined')
            elif constraint == 'InputLimitConstraints':
                try:
                    self._planner.setInputLimits(np.transpose(self._limits_u))
                except AttributeError:
                    print('The required attributes for setting ' + constraint + ' are not defined')
            elif constraint == 'LinearConstraints':
                try:
                    self._planner.setLinearConstraints(self._lin_constr, self._r_body)
                except AttributeError:
                    print('The required attributes for setting ' + constraint + ' are not defined')
            elif constraint == 'RadialConstraints':
                try:
                    self._planner.setRadialConstraints(self._obstacles, self._r_body)
                except AttributeError:
                    print('The required attributes for setting ' + constraint + ' are not defined')
            elif constraint == 'SelfCollisionAvoidanceConstraints':
                try:
                    self._planner.setSelfCollisionAvoidanceConstraints(self._r_body)
                except AttributeError:
                    print('The required attributes for setting ' + constraint + ' are not defined')
            else:
                print('No function to set the parameters for this constraint type is defined')

    def establish_ros_connections(self):
        self._cmd_pub = rospy.Publisher(
            "/boxer_velocity_controller/cmd_vel", Twist, queue_size=1,
        )
        self._odom_sub = rospy.Subscriber(
            "/odometry/filtered", Odometry, self._odom_cb, queue_size=1,
        )
        self._goal_sub = rospy.Subscriber(
            "/mpc/goal", PoseStamped, self._goal_cb, queue_size=1,
        )

        self._lidar_sub = rospy.Subscriber(
            "/front/scan", LaserScan, self._lidar_cb, queue_size=1,
        )

    def _goal_cb(self, goal_msg: PoseStamped):
        goal_position = [goal_msg.pose.position.x,  goal_msg.pose.position.y]
        if len(goal_position) != 2:
            rospy.logwarn("Goal ignored because of dimension missmatch")
        goal_dict = {
            "subgoal0": {
                "weight": 1.0,
                "is_primary_goal": True,
                "indices": [0, 1],
                "parent_link": 'origin',
                "child_link": rospy.get_param('/robot/end_link'),
                "desired_position": goal_position,
                "epsilon": 0.4,
                "type": "staticSubGoal"
            }
        }
        self._goal = GoalComposition(name="goal1", content_dict=goal_dict)
        self._planner.setGoalReaching(self._goal)


    def _odom_cb(self, odom_msg: Odometry):
        self._q = np.array([
            odom_msg.pose.pose.position.x,
            odom_msg.pose.pose.position.y,
            get_rotation(odom_msg.pose.pose),
        ])
        self._qdot = np.array([
            odom_msg.twist.twist.linear.x,
            odom_msg.twist.twist.linear.y,
            odom_msg.twist.twist.angular.z,
        ])

    def _lidar_cb(self, msg: PointCloud2):
        cloud_points = []
        angle = msg.angle_min

        for r in msg.ranges:
            # Filter out invalid range values
            if r > msg.range_min and r < msg.range_max:
                x = r * math.cos(angle)
                y = r * math.sin(angle)
                z = 0.0  # Set z value as 0 (assuming a 2D plane)

                cloud_points.append([x, y, z])
            angle += msg.angle_increment

        self.listener.waitForTransform("/odom", msg.header.frame_id, rospy.Time(0), rospy.Duration(5))
        (self._translation, self._rotation) = self.listener.lookupTransform("/odom", msg.header.frame_id, rospy.Time(0))


        if self._translation is not None:
            cloud_points = np.array(cloud_points)


            R = quaternion_to_rotation_matrix(self._rotation)

            transformed_points = np.dot(cloud_points[:, :3], R.T)
            transformed_points += [self._translation[0],
                                   self._translation[1],
                                   self._translation[2]]
            # print('transformed')
            # Use pc2.read_points to iterate through the PointCloud2 message

            # Now, point_cloud_array contains the array of points from the PointCloud2 message
            # Use this array for further processing or manipulation
            # Example: print the first 5 points


            self._lidar_pointcloud = np.array(transformed_points)


    def compute_constraints(self, robot_state: np.ndarray, point_cloud: np.ndarray) -> Tuple[List, List]:
        """
        Computes linear constraints given a pointcloud as numpy array.
        The seed point is the robot_state.
        """

        angle = robot_state[2]
        rot_matrix = np.array([
                [np.cos(angle), -np.sin(angle)],
                [np.sin(angle), np.cos(angle)],
        ])

        position_lidar = self._translation[:2]

        lidar_position = np.array([position_lidar[0], position_lidar[1], 0.0])


        self._fsd.set_position(lidar_position)
        if len(point_cloud)>0:
            self._fsd.compute_constraints(point_cloud)
        return list(self._fsd.asdict().values()), self._fsd.constraints()

    def act(self):
        vel_action = self._action * self._dt + self._qudot
        cmd_msg = Twist()
        cmd_msg.linear.x = vel_action[0]
        cmd_msg.angular.z = vel_action[1]
        self._cmd_pub.publish(cmd_msg)
        self._qudot = vel_action

    def run(self):


        while not rospy.is_shutdown():
            linear_constraints = []
            if self._lidar_pointcloud is not None:
                halfplanes = []
                for j in range(self._N):
                    if not self._output is None and self._exitflag >= 0:
                        key = "x{:02d}".format(j + 1)
                        ref_q = self._output[key][0:3]

                        plan_pose = Pose()
                        plan_pose.position.x = ref_q[0]
                        plan_pose.position.y = ref_q[1]
                        plan_pose.position.z = 0.01
                        self.visual_robot.add_marker(plan_pose)
                    else:
                        ref_q = self._q
                    linear_constraints_j, halfplanes_j = self.compute_constraints(ref_q, self._lidar_pointcloud)
                    linear_constraints.append(linear_constraints_j)
                    halfplanes.append(halfplanes_j)

                self._planner.setLinearConstraints(linear_constraints, r_body=self._r_body)
                print('linear constraints are set')
                print(linear_constraints)
            if self._goal:
                self._action, self._output, self._exitflag = self._planner.computeAction(self._q, self._qdot, self._qudot)
                rospy.loginfo(self._action)
                rospy.loginfo(self._exitflag)
                print(self._output)


            self.act()
            if self.check_goal_reaching(self._q):
                print('GOAL REACHED')

            self.visualize(linear_constraints)
            self._rate.sleep()

    def visualize(self,linear_constraints):
        if len(linear_constraints)>0:
            for constraint in linear_constraints:
                self.visual_constraints.add_constraint_line(constraint[0][:2], -constraint[0][-1], length=10.0)


        if self._goal is not None:
            goal_pose = Pose()
            goal_pose.position.x = self._goal.primary_goal().position()[0]
            goal_pose.position.y = self._goal.primary_goal().position()[1]
            goal_pose.position.z = 0.01
            self.visual_goal.add_marker(goal_pose)

        robot_pose = Pose()
        robot_pose.position.x = self._q[0]
        robot_pose.position.y = self._q[1]
        robot_pose.position.z = 0.01
        self.visual_robot.add_marker(robot_pose)

        self.visuals.publish()

    def check_goal_reaching(self, q):
        if self._goal is not None:
            primary_goal = self._goal.primary_goal()
            goal_dist = np.linalg.norm(q[:2] - primary_goal.position()) # todo remove hard coded dimension, replace it with fk instead
            if goal_dist <= primary_goal.epsilon():
                return True
            return False
        return False

if __name__ == "__main__":
    try:
        mpc_node = MPCNode()
        mpc_node._output: Union[dict, None] = None
        mpc_node.run()
    except rospy.ROSInterruptException:
        pass
    
